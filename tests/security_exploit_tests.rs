// Security Exploit Prevention Tests
// Tests for all the security fixes we implemented

use narayana_server::http::ApiState;
use narayana_storage::{
    ColumnStore,
    InMemoryColumnStore,
    database_manager::DatabaseManager,
    human_search::HumanSearchEngine,
    webhooks::WebhookManager,
    workers::WorkerManager,
    cognitive::CognitiveBrain,
    query_learning::QueryLearningEngine,
};
use narayana_server::security::TokenManager;
use axum::{
    body::{Body, HttpBody},
    http::{Request, StatusCode},
    Router,
};
use tower::ServiceExt;
use serde_json::{json, Value};
use std::sync::Arc;

fn create_test_state() -> ApiState {
    let storage: Arc<dyn ColumnStore> = Arc::new(InMemoryColumnStore::new());
    let db_manager = Arc::new(DatabaseManager::new());
    let search_engine = Arc::new(HumanSearchEngine::new());
    let webhook_manager = Arc::new(WebhookManager::new());
    // For tests, we need a runtime - use a simple mock
    use narayana_storage::workers::{WorkerManager, WorkerRuntime, WorkerExecutionContext, WorkerResponse};
    struct MockRuntime;
    #[async_trait::async_trait]
    impl WorkerRuntime for MockRuntime {
        async fn execute(&self, _ctx: WorkerExecutionContext) -> anyhow::Result<WorkerResponse> {
            Ok(WorkerResponse {
                status: 200,
                headers: std::collections::HashMap::new(),
                body: b"Mock response".to_vec(),
                metrics: narayana_storage::workers::ExecutionMetrics {
                    cpu_time_ms: 0,
                    memory_bytes: 0,
                    execution_time_ms: 0,
                    subrequests: 0,
                    request_size: 0,
                    response_size: 0,
                },
            })
        }
        
        fn validate_code(&self, code: &str) -> anyhow::Result<()> {
            if code.is_empty() {
                anyhow::bail!("Code cannot be empty")
            } else {
                Ok(())
            }
        }
        
        fn name(&self) -> &str {
            "MockRuntime"
        }
    }
    let runtime: Arc<dyn WorkerRuntime> = Arc::new(MockRuntime);
    let worker_manager = Arc::new(WorkerManager::new(runtime));
    let brain = Arc::new(CognitiveBrain::new());
    let query_learning = Arc::new(QueryLearningEngine::new());
    let token_manager = Arc::new(TokenManager::new("test_secret_key_for_testing_only".to_string()));

    ApiState {
        storage,
        db_manager,
        search_engine,
        webhook_manager,
        worker_manager,
        brain,
        query_learning,
        ws_state: None,
        token_manager,
    }
}

fn create_test_router(state: ApiState) -> Router {
    narayana_server::http::create_router(state)
}

async fn get_auth_token(app: &Router) -> String {
    // Setup
    let setup_request = json!({
        "name": "Test Admin",
        "username": "testadmin",
        "password": "testpassword123"
    });

    let setup_response = app
        .clone()
        .oneshot(
            Request::builder()
                .uri("/api/v1/auth/setup")
                .method("POST")
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&setup_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(setup_response.status(), StatusCode::OK);

    // Login
    let login_request = json!({
        "username": "testadmin",
        "password": "testpassword123"
    });

    let login_response = app
        .clone()
        .oneshot(
            Request::builder()
                .uri("/api/v1/auth/login")
                .method("POST")
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&login_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    let body = axum::body::to_bytes(login_response.into_body(), usize::MAX).await.unwrap();
    let json: Value = serde_json::from_slice(&body).unwrap();
    json["token"].as_str().unwrap().to_string()
}

#[tokio::test]
async fn test_protected_table_cannot_be_queried() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Try to query the protected narayana_ui_users table
    // First, we need to find its table ID, but we'll try a common approach
    // The table should be protected and not accessible via normal API

    // Try to query with a table ID that might be the users table
    // Since we can't easily get the table ID, we'll test that the table
    // is filtered out from the tables list
    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/tables")
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
    let json: Value = serde_json::from_slice(&body).unwrap();
    let tables = json["tables"].as_array().unwrap();

    // The protected table should not appear in the list
    assert!(!tables.iter().any(|t| t["name"] == "narayana_ui_users"));
}

#[tokio::test]
async fn test_protected_table_cannot_be_created() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Try to create a table with the protected name
    let create_request = json!({
        "table_name": "narayana_ui_users",
        "schema": {
            "fields": [
                {"name": "id", "data_type": "String"},
                {"name": "username", "data_type": "String"}
            ]
        }
    });

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/tables")
                .method("POST")
                .header("authorization", format!("Bearer {}", token))
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&create_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::FORBIDDEN);
}

#[tokio::test]
async fn test_query_limit_validation() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Create a test table first
    let create_request = json!({
        "table_name": "test_table",
        "schema": {
            "fields": [
                {"name": "id", "data_type": "String"},
                {"name": "value", "data_type": "Int32"}
            ]
        }
    });

    let create_response = app
        .clone()
        .oneshot(
            Request::builder()
                .uri("/api/v1/tables")
                .method("POST")
                .header("authorization", format!("Bearer {}", token))
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&create_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(create_response.status(), StatusCode::OK);

    let body = axum::body::to_bytes(create_response.into_body(), usize::MAX).await.unwrap();
    let json: Value = serde_json::from_slice(&body).unwrap();
    let table_id = json["table_id"].as_u64().unwrap();

    // Try to query with limit exceeding max (10000)
    let response = app
        .oneshot(
            Request::builder()
                .uri(format!("/api/v1/tables/{}/query?limit=20000", table_id))
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    // Should either reject or cap the limit
    // The implementation caps it, so we check it doesn't exceed max
    assert!(response.status() == StatusCode::OK || response.status() == StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_column_index_bounds_validation() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Create a test table with 2 columns
    let create_request = json!({
        "table_name": "test_table",
        "schema": {
            "fields": [
                {"name": "id", "data_type": "String"},
                {"name": "value", "data_type": "Int32"}
            ]
        }
    });

    let create_response = app
        .clone()
        .oneshot(
            Request::builder()
                .uri("/api/v1/tables")
                .method("POST")
                .header("authorization", format!("Bearer {}", token))
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&create_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    let body = axum::body::to_bytes(create_response.into_body(), usize::MAX).await.unwrap();
    let json: Value = serde_json::from_slice(&body).unwrap();
    let table_id = json["table_id"].as_u64().unwrap();

    // Try to query with column index out of bounds (table has 2 columns, index 0-1)
    let response = app
        .oneshot(
            Request::builder()
                .uri(format!("/api/v1/tables/{}/query?columns=0,1,5", table_id))
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_payload_size_limit() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Create a test table
    let create_request = json!({
        "table_name": "test_table",
        "schema": {
            "fields": [
                {"name": "id", "data_type": "String"},
                {"name": "data", "data_type": "String"}
            ]
        }
    });

    let create_response = app
        .clone()
        .oneshot(
            Request::builder()
                .uri("/api/v1/tables")
                .method("POST")
                .header("authorization", format!("Bearer {}", token))
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&create_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    let body = axum::body::to_bytes(create_response.into_body(), usize::MAX).await.unwrap();
    let json: Value = serde_json::from_slice(&body).unwrap();
    let table_id = json["table_id"].as_u64().unwrap();

    // Create a very large payload (exceeding 100MB limit)
    let large_string = "x".repeat(101 * 1024 * 1024); // 101MB
    let insert_request = json!({
        "columns": [
            {"String": ["test_id"]},
            {"String": [large_string]}
        ]
    });

    let response = app
        .oneshot(
            Request::builder()
                .uri(format!("/api/v1/tables/{}/insert", table_id))
                .method("POST")
                .header("authorization", format!("Bearer {}", token))
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&insert_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_query_parameter_count_limit() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Create a test table
    let create_request = json!({
        "table_name": "test_table",
        "schema": {
            "fields": [
                {"name": "id", "data_type": "String"}
            ]
        }
    });

    let create_response = app
        .clone()
        .oneshot(
            Request::builder()
                .uri("/api/v1/tables")
                .method("POST")
                .header("authorization", format!("Bearer {}", token))
                .header("content-type", "application/json")
                .body(Body::from(serde_json::to_string(&create_request).unwrap()))
                .unwrap(),
        )
        .await
        .unwrap();

    let body = axum::body::to_bytes(create_response.into_body(), usize::MAX).await.unwrap();
    let json: Value = serde_json::from_slice(&body).unwrap();
    let table_id = json["table_id"].as_u64().unwrap();

    // Create query with too many parameters (max is 100)
    let mut query_params = String::new();
    for i in 0..150 {
        if i > 0 {
            query_params.push('&');
        }
        query_params.push_str(&format!("param{}={}", i, "x".repeat(1000)));
    }

    let response = app
        .oneshot(
            Request::builder()
                .uri(format!("/api/v1/tables/{}/query?{}", table_id, query_params))
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_brain_id_validation() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Try with invalid brain ID (path traversal attempt)
    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/brains/../../../etc/passwd/thoughts")
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_webhook_id_validation() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Try with invalid webhook ID (path traversal attempt)
    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/webhooks/../../../etc/passwd")
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_memory_type_whitelist() {
    let state = create_test_state();
    let app = create_test_router(state);
    let token = get_auth_token(&app).await;

    // Try with invalid memory type (injection attempt)
    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/brains/test_brain/memories?type=<script>alert('xss')</script>")
                .header("authorization", format!("Bearer {}", token))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    // Should either reject or default to episodic
    assert!(response.status() == StatusCode::OK || response.status() == StatusCode::BAD_REQUEST);
}

